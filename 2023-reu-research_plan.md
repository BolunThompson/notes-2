# YT Enzo-E Octree 

## Notes
### Steps for YT
1. Write frontend for YT to load Enzo-E data in an octree format
2. If extra time: optimize the frontend so that it can be used in the real world
3. Demonstrate that the octree frontend can be used in a real-world style problem
    - Halo finding?
4. Perhaps write an octree frontend for FLASH and GAMER formats?
### Additional Goals
1. Go through ML Workshops
    - Perhaps complete a project using ML? Although I don't want to try to find
        a project for a technology.
2. Complete REU tasks
### TODO
- Should I add a benefits section?


## Investigators
- Bolun Thompson

  2022 Summer REU Extra Help Intern

  High School Student

- Matt Turk

  Assistant Professor at the School of Information Sciences

## Purpose
`yt` currently interprets Enzo-E data in a grid-based format, despite the data
natively being octree-based. The purpose of this project is to write a frontend
usable in the real-world to load Enzo-E data into `yt` in an octree-based
format.

## Background
`yt` is a software package for the analysis of volumetric data. It has been used
for the analysis of data in a variety of domains, including astrophysics,
seismology, and molecular dynamics. It can interpret data stored as particles,
unstructured meshes, and, of note here, both grid-based and octree-based adaptive
mesh refinement (AMR) data. It uses a variety of frontends to load
datasets from various simulation codes.

Enzo is a grid-based parallel adaptive mesh refinement simulation code for the
investigation of astrophysical phenomena such as the formation of stars and
galaxies. Enzo-E is a branch of the Enzo code rewritten to use Cello, a highly
scalable parallel array-of-octree AMR framework.

The eventual purpose of Enzo-E is to run exascale astrophysical simulations;
however, Enzo-E frontend for `yt` does not currently reasonably scale beyond 
datasets of a^3 blocks (b TB), while the datasets generated by Enzo-E may be
up to c^3 (d TB).

One reason for this is that the current Enzo-E frontend interprets the octree
data as grid-based, not as an octree---a legacy of Enzo's grid-based design.
Loading data in a grid-based format necessitates the inefficient instantiation
of a Python object for each grid. Octs can instead be efficiently built as
structures at most 88 bytes large. This leads to octree based frontends
generally having improved performance over grid-based frontends, motivating
our project to implement an octree-based Enzo-E frontend for `yt`.

The Flash and GAMER frontends are other examples of octree-based simulation
codes where `yt` loads their  datasets as grids, not as octrees. Scaling
issues may also impact these frontends, so future work could be to rewrite
those frontends using the octree facilities.

### Previous Work
In the summer of 2022, preliminary work was done refactoring the `yt` code to
support loading in Enzo-E data as an octree, as well as exploratory scripts.

## Objectives
1. Write and test a frontend for `yt` to load Enzo-E data in an octree format
2. Optimize the frontend so that it can be used for real world exascale datasets
3. Demonstrate that the octree frontend can be used in a real-world style problem
4. Write an octree frontend for FLASH and GAMER formats, and repeat the above
   process
